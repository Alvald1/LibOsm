/*
    Copyright © 2010 par Marc Sibert

    This file is part of LIBOSM

    LIBOSM is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    LIBOSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with LIBOSM.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \file
 * \author Marc Sibert
 */
// Class automatically generated by Dev-C++ New Class wizard

#include "way.h" // class's header file

void Way::addNode(const unsigned long& aNode)
{
    fNodes.push_back(aNode);
}

/*
void Way::addNode(const Node& aNode)
{
    if (fNodes.empty())
        fBound = aNode;
    else
        fBound.elargir(aNode);
    fNodes.push_back(aNode.id());
}
*/

ostream& operator<<(ostream& aStream, const Way& aWay)
{
    aStream << "\t<way ";
    Element(aWay).afficher(aStream);
    aStream << ">" << endl;
    aWay.afficherNodes(aStream);
    aWay.afficherTags(aStream);
    aStream << "\t</way>" << endl;
    return aStream;
}

ostream& Way::afficherNodes(ostream& aStream) const
{
    for (list<unsigned long>::const_iterator i = fNodes.begin(); i != fNodes.end(); ++i) {
        aStream << "\t\t<nd ref=\"" << *i << "\" />" << endl;
    }
    return aStream;
}

const string Way::NOM = "way";

bool Way::operator==(const Way& aWay) const
{
// Mêmes adresses ?
    if (this == &aWay) return true;
// Héritages identiques ?
    if (!(Element::operator==(aWay))) return false;
// Mêmes listes de Nodes ?
    if (fNodes.size() != aWay.fNodes.size()) return false;

    ListeNodes::const_iterator a = fNodes.begin();
    ListeNodes::const_iterator b = aWay.fNodes.begin();
    while ((a != fNodes.end()) && (b != aWay.fNodes.end())) {
        if (*a++ != *b++) return false;
    }
    return true;
}
